"""This is ExploitManager class

Has queue which is loader for exploits which are one by one checked. For less
process congestion thread for this process sleeps every 13 miliseconds if queue
is empty.
"""
__author__ = "Ales Lerch"

import time
import logging
import exploit_checker as ec
import threading
import multiprocessing

class ExploitManager:

    class Exploit:

        def __init__(self,data):
            self.data = data

    def __init__(self,exploitChecker):
        self.log = logging.getLogger('mainLogger')
        self.exChecker = exploitChecker
        self.exploit_queue = multiprocessing.Queue()

    def add_to_que(self,expl):
        self.exploit_queue.put_nowait(expl)

    def que_checking(self):
        self.log.info('Que is waiting for checking exploit')
        while True:
            if not self.exploit_queue.empty():
                while not self.exploit_queue.empty():
                    self.exChecker.checkThisData(self.exploit_queue.get())
            else:
                time.sleep(0.0130)
            #print(threading.current_thread(),threading.current_thread().name)

    def printQue(self):
        while not self.exploit_queue.empty():
            print(self.exploit_queue.get())

if __name__ == "__main__":
    q = ExploitManager()
    q.add_to_que('teste')
    q.printQue()
    q.que_checking()
