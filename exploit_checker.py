"""This is Exploit checker module.

This module does checking for exploits on input data and tries to attach
invididual rules into specific directory.
"""

__author__ = "Ales Lerch"

from tabulate import tabulate
import mongodatabase as mdb
import importlib
import logging
import os
import re

class ExploitChecker:

    def __init__(self,genData,directory='rules'):
        self.rules = {}
        self.directory = directory
        self.methods = ('match_exploit',)
        self.datab = mdb.ExploitMDB()
        self.log = logging.getLogger('mainLogger')
        self.total = 0
        self.gen_data = genData

        try:
            self.log.info('Loading all exploits from %s' % self.directory)
            self.loadExploits()
        except ValueError as e:
            self.log.error('Something went wrong with loading exploits' % e)

        self.log.info('Checking all the exploits which were founded!')
        self.checkExploits()
        #print("Error: While checking exploits",e)

    def loadExploits(self):
        def checkMN(name):
            #print unmatched module?
            return re.match(r'[a-z_]+.py',name) and name != "__init__.py"

        rules = [d for d in os.listdir(os.path.join(".",self.directory)) if not os.path.isdir(d) and checkMN(d)]
        for rule in rules:
            try:
                name = os.path.splitext(rule)[0]
                mod = "%s.%s" % (self.directory,name)
                self.rules[name] = {}
                self.rules[name]['lib'] = importlib.import_module(mod)
                self.rules[name]['mod'] = mod
                self.rules[name]['path'] = os.path.abspath(rule)
            except Exception as e:
                self.log.error('Something wrong with loading module %s,%s' % (rule,e))

    def checkExploits(self):
        check_sum = len(self.rules)
        checked_rules = []
        if not self.rules:
            raise ValueError('[Error] No classifiers were loaded')

        for key, rule in self.rules.items():
            for mtd in self.methods:
                method = getattr(rule['lib'],mtd,None)
                if callable(method):
                    ch_rule = True
                    self.log.info('Classifier %s has %s method' % (rule['lib'].__name__,mtd))
                    try:
                        if not method('') and method('') is not None:
                            code = 'OK'
                        else:
                            code = 'ERROR'
                            ch_rule = False
                        self.log.info('Testing method ... %s' % code)
                    except AttributeError as a:
                        self.log.error('During testing method was atribute error %s' % a)
                else:
                    self.log.error("Rule %s doesn't have %s method" % (rule['lib'].__name__,mtd))
                    ch_rule = False
            checked_rules.append(ch_rule)
            self.rules[key]['checked_rules'] = ch_rule
        if check_sum == len(checked_rules):
            self.log.info('All rules has been tested')
        if any(checked_rules):
            self.log.info('All classifiers are working correctly')
        else:
            self.log.warning('Some classifiers are incorrect')

    def checkThisData(self,data):
        resolve = True
        job = False
        for rule, val in self.rules.items():
            try:
                resolve = val['lib'].match_exploit(data)
                self.rules[rule]['is_exploit'] = resolve
            except Exception as e:
                self.log.error('Classifier %s:' % val['lib'].__name__ ,e)
                self.rules[rule]['is_exploit'] = False

            # gen_data is just control if option generate fake data is on
            if resolve or self.gen_data:
                if self.gen_data:
                    myattacks = ['rules.sql_injeciton','rules.xss_atack','rules.dir_attack',
                            'rules.bots']
                    data['attacktype'] = myattacks[random.randint(0,4)]
                else:
                    data['attacktype'] = val['lib'].__name__
                data['total_dataflow'] = self.total + 1
                job = self.datab.save(data)
                self.total = 0
                self.rules[rule]['is_saved'] = job
            else:
                self.total += 1
                self.rules[rule]['is_saved'] = False
        self.printMyModules()

    def printMyModules(self):
        if self.rules:
            table = [
                [tab['mod'],str(tab['checked_rules']),os.path.basename(tab['path']),str(tab['is_exploit']),str(tab['is_saved'])] for tab in self.rules.values()
                  ]
            headers = [
                    'Rule Name','Check','Rule Path',
                    'Detection','Saved',
                    ]
            self.log.debug("\n" + tabulate(table, headers, tablefmt="psql"))

if __name__ == "__main__":
    ec = ExploitChecker()
    ec.checkThisData('')
